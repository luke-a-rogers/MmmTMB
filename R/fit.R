## usethis namespace: start
#' @importFrom Rcpp sourceCpp
#' @useDynLib mmmTMB, .registration = TRUE
## usethis namespace: end
NULL


#' Fit a Markov Movement Model to Mark-Recapture Data
#'
#' @description Estimate movement probabilities among areas by fitting a Markov
#' movement model to mark release and recovery data.
#'
#' Array dimensions are abbreviated for space and are given by:
#' \itemize{
#'   \item{\code{nt}: Count of time units in the data}
#'   \item{\code{na}: Count of areas in the data}
#'   \item{\code{ng}: Count of class categories}
#' }
#'
#' @usage mmmTMB(data_list, ...)
#'
#' @param released_3d [array()] Release counts by release time, release area,
#' and class; \code{dim = c(nt, na, ng)}
#' @param recovered_5d [array()] Recovery counts by release time, recovery
#' time, release area, recovery area, and class;
#' \code{dim = c(nt, nt, na, na, ng)}
#' @param capture_rate_2d [array()] Instantaneous capture rate per time unit by
#' time and area; \code{dim = c(nt, na)}
#' @param report_ratio_2d [array()] Reporting ratio by time and area;
#' \code{dim = c(nt, na)}
#' @param tag_loss_rate [numeric()] Instantaneous tag loss rate per time unit,
#' assumed constant across times, areas, and classes
#' @param imm_loss_ratio [numeric()] Ratio of tags lost during release, assumed
#' constant across times, areas, and classes
#' @param template_2d [array()] Template indicating movement parameters to
#' estimate; \code{dim = c(na, na)}. See Details.
#' @param recapture_delay [integer()] Number of time units after release when
#' recovery becomes possible, \code{>= 1}.
#' @param error_family [integer()] One of 0: Poisson; 1: NB1; or 2: NB2
#' @param result_units [integer()] Results time unit as a multiple of the data
#' time unit. See details.
#' @param time_process [integer()] Time process for movement
#' rates. 0: Constant; 1: Time varying
#' @param time_pattern [integer()] Timevarying pattern for movement
#' probabilities. One of 0: Constant; 1: Stepped; 2: Cyclical. See Details.
#' @param pattern_size [integer()] Number of levels in the \code{time_pattern}.
#' @param newton_steps [integer()] Number of Newton optimization steps
#' @param nlminb_loops [integer()] Number of times to run [stats::nlminb()]
#' optimization.
#' @param openmp_cores [integer()] Number of cores for TMB
#' @param simulate_value [logical()] Simulate \code{recovered_5d}? See Details.
#' @param capture_map_2d [array()] Custom \code{TMB} map for
#' \code{log_capture_bias_2d} parameters, \code{dim = c(na, ng)}. See Details.
#' @param structure_list [list()] Input data and model structure constants as
#' a list. See Details.
#' @param parameter_list [list()] Input (log) initial or simulation parameter
#' values. See Details.
#' @param optimizer_list [list()] Input optimizer and \code{OpenMP} values. See
#' Details.
#' @param nlminb_control [list()] See [mmmTMBcontrol()]
#'
#' @details
#' Describe \code{template_2d}...
#' Describe \code{result_units}...
#' Describe \code{time_pattern}...
#' Describe \code{capture_map_2d}...
#' Describe \code{structure_list}...
#' Describe \code{parameter_list}...
#' Describe \code{optimizer_list}...
#' Describe \code{simulate_value}...
#'
#' @return An [list()] of class \code{mmmTMB} with elements:
#' \itemize{
#'   \item{\code{adfun}: The TMB AD model object}
#'   \item{\code{model}: Output from [nlminb()]}
#'   \item{\code{structure}: A [list()] of data and constants}
#'   \item{\code{parameter}: A [list()] of initial (log) parameter values}
#'   \item{\code{optimizer}: A [list()] of optimizer constants}
#'   \item{\code{results}: A [list()] of results data frames}
#'   \item{\code{map}: A [list()] of parameter map [factor()]s}
#'   \item{\code{map}: A [list()] of random effects}
#'   \item{\code{sd_report}: A [list()] generated by [sdreport()]}
#'   \item{\code{conv}: A [list()] of convergence diagnostics}
#'   \item{\code{mgc}: The maximum absolute gradient component}
#' }
#'
#' @export
#'
#' @examples
#' # Fit
#' fit_list <- mmmTMB(
#'   released_3d = sim_released_3d,
#'   recovered_5d = sim_recovered_5d,
#'   capture_rate_2d = sim_capture_rate_2d,
#'   report_ratio_2d = sim_report_ratio_2d,
#'   tag_loss_rate = 0.02,
#'   imm_loss_ratio = 0.1,
#'   template_2d = sim_template_2d,
#'   openmp_cores = floor(parallel::detectCores() / 2))
#'
#'
mmmTMB <- function (released_3d, # Data
                    recovered_5d,
                    capture_rate_2d,
                    report_ratio_2d,
                    tag_loss_rate,
                    imm_loss_ratio,
                    template_2d, # Structure
                    recapture_delay = 1,
                    error_family = 1,
                    result_units = 1,
                    time_process = 0,
                    time_pattern = 0,
                    pattern_size = 0,
                    newton_steps = 0, # Optimizer
                    nlminb_loops = 0,
                    openmp_cores = NULL,
                    simulate_value = NULL,
                    capture_map_2d = NULL,
                    structure_list = NULL, # Optional lists
                    parameter_list = NULL,
                    optimizer_list = NULL,
                    nlminb_control = mmmTMBcontrol()) {


  #---------------- Start the clock -------------------------------------------#

  tictoc::tic("mmmTMB")

  #---------------- Unpack arguments ------------------------------------------#

  if (!is.null(structure_list)) {
    released_3d <- structure_list$released_3d
    template_2d <- structure_list$template_2d
    error_family <- structure_list$error_family
  }
  if (!is.null(optimizer_list)) {
    newton_steps <- optimizer_list$newton_steps
    nlminb_loops <- optimizer_list$nlminb_loops
    openmp_cores <- optimizer_list$openmp_cores
  }

  #---------------- Check arguments: Part 1 of 2 ------------------------------#

  # TODO: check that structure_list has movement_index


  #---------------- Assign dimensions -----------------------------------------#

  np <- sum(template_2d)
  nt <- dim(released_3d)[1]
  na <- dim(released_3d)[2]
  ng <- dim(released_3d)[3]

  #---------------- Check arguments: Part 2 of 2 ------------------------------#



  #---------------- Define the number of cores --------------------------------#

  if (!is.null(openmp_cores)) {TMB::openmp(n = openmp_cores)}

  #---------------- Define the movement index ---------------------------------#

  if (time_process == 0) {
    nv <- 1
    movement_index <- rep(0, nt)
  } else {
    if (time_pattern == 0) {
      nv <- 1
      movement_index <- rep(0, nt)
    } else if (time_pattern == 1) {
      nv <- pattern_size
      movement_index <- rep(seq_len(nv) - 1, each = ceiling(nt/nv))[seq_len(nt)]
    } else if (time_pattern == 2) {
      nv <- pattern_size
      movement_index <- rep((seq_len(nv) - 1), ceiling(nt/nv))[seq_len(nt)]
    } else {
      warning("time_pattern not implemented")
    }
  }

  #---------------- Create the data list --------------------------------------#

  cat("creating tmb_data \n")
  if (!is.null(structure_list)) {
    tmb_data <- structure_list
  } else {
    tmb_data <- list(released_3d = released_3d,
                     recovered_5d = recovered_5d,
                     capture_rate_2d = capture_rate_2d,
                     report_ratio_2d = report_ratio_2d,
                     tag_loss_rate = tag_loss_rate,
                     imm_loss_ratio = imm_loss_ratio,
                     template_2d = template_2d,
                     recapture_delay = recapture_delay,
                     error_family = error_family,
                     result_units = result_units,
                     time_process = time_process,
                     movement_index = movement_index)
  }

  #---------------- Create the parameter list ---------------------------------#

  cat("creating tmb_parameters \n")
  if (!is.null(parameter_list)) {
    tmb_parameters <- parameter_list
  } else {
    tmb_parameters <- list(
      movement_parameters_3d = array(0, dim = c(nv, np, ng)),
      log_capture_bias_2d = array(0, dim = c(na, ng)),
      log_natural_mortality = 0,
      log_dispersion = 0
      # TODO: Add parameters for time-varying
    )
  }

  #---------------- Define map list -------------------------------------------#

  cat("creating tmb_map \n")
  tmb_map <- list()

  # Augment by capture bias map
  if (!is.null(capture_map_2d)) {
    tmb_map <- c(tmb_map, list(log_capture_bias_2d = as.factor(capture_map_2d)))
  } else {
    tmb_map <- c(tmb_map, list(log_capture_bias_2d = factor(rep(1, na * ng))))
  }

  # Map off log_dispersion?
  if (error_family == 0) {
    tmb_map <- c(tmb_map, list(log_dispersion = as.factor(NA)))
  }

  #---------------- Define random effects -------------------------------------#

  # Initialize tmb_random
  tmb_random <- character(0)

  #---------------- Create the simulation object ------------------------------#

  # Use isTRUE(simulate_value) to accommodate NULL

  #---------------- Create the model object -----------------------------------#
  # TODO: Add previous fit option

  cat("creating tmb_obj \n")
  tictoc::tic("creating tmb_obj")
  tmb_obj <- TMB::MakeADFun(data = tmb_data,
                            parameters = tmb_parameters,
                            map = tmb_map,
                            random = tmb_random,
                            DLL = "mmmTMB")
  tictoc::toc()

  #---------------- Optimize the objective function ---------------------------#

  cat("\nmodel mgc \n")
  {
    # Start the clock
    tictoc::tic("nlminb")

    # Perform initial optimization
    tmb_opt <- stats::nlminb(
      start = tmb_obj$par,
      objective = tmb_obj$fn,
      gradient = tmb_obj$gr,
      control = nlminb_control)

    # Iterate optimization
    if (nlminb_loops > 0) {
      cat("\nrunning extra nlminb loops \n")
      for (i in seq(2, nlminb_loops, length = max(0, nlminb_loops - 1))) {
        cat(paste0("running nlminb loop #", i, "\n"))
        temp <- tmb_opt[c("iterations", "evaluations")]
        tmb_opt <- stats::nlminb(
          start = tmb_opt$par,
          objective = tmb_obj$fn,
          gradient = tmb_obj$gr,
          control = nlminb_control)
        tmb_opt[["iterations"]] <- tmb_opt[["iterations"]] + temp[["iterations"]]
        tmb_opt[["evaluations"]] <- tmb_opt[["evaluations"]] + temp[["evaluations"]]
      }
    }

    # TODO: Troubleshoot Newton steps: output fed into next input correctly?
    # Perform additional Newton steps
    if (newton_steps > 0) {
      cat("\nrunning newton steps \n")
      for (i in seq_len(newton_steps)) {
        cat(paste0("running newton step #", i, "\n"))
        g <- as.numeric(tmb_obj$gr(tmb_opt$par))
        h <- optimHess(tmb_opt$par, fn = tmb_obj$fn, gr = tmb_obj$gr)
        tmb_opt$par <- tmb_opt$par - solve(h, g)
        tmb_opt$objective <- tmb_obj$fn(tmb_opt$par)
      }
    }
    # Stop the clock
    tictoc::toc()
  }

  #---------------- Create sd report ------------------------------------------#

  cat("\nsd_report mgc \n")
  sd_report <- TMB::sdreport(tmb_obj)
  conv <- get_convergence_diagnostics(sd_report)
  mgc <- max(abs(conv$final_grads))

  #---------------- Create optimizer list -------------------------------------#

  if (is.null(optimizer_list)) {
    optimizer_list <- list(newton_steps = newton_steps,
                           nlminb_loops = nlminb_loops,
                           openmp_cores = openmp_cores)
  }

  #---------------- Create movement probability results -----------------------#

  tictoc::tic("computing movement estimates and std errs")
  pars <- subset_by_name(tmb_opt$par, "movement_parameters_3d")
  if (time_process == 0) {
    covs <- subset_by_name(sd_report$cov.fixed, "movement_parameters_3d")
  } else {
    # warning("Parameters are a random effect: Figure out where to access covs")
    covs <- subset_by_name(sd_report$cov.fixed, "movement_parameters_3d")
  }
  mpr_df <- create_movement_probability_results(
    pars = pars,
    covs = covs,
    dims = c(nv, np, nt, na, ng),
    tp_2d = template_2d,
    result_units = result_units,
    n_draws = 1000)
  tictoc::toc()

  #---------------- Create natural mortality results --------------------------#

  nmr_mat <- summary(sd_report)["natural_mortality_results", , drop = FALSE]
  rownames(nmr_mat) <- NULL
  colnames(nmr_mat) <- c("Estimate", "SE")
  nmr_df <- as.data.frame(nmr_mat)

  #---------------- Create capture bias results -------------------------------#

  cbr_ind <- which(rownames(summary(sd_report)) == "capture_bias_2d")
  cbr_mat <- matrix(0, nrow = na * ng, ncol = 4)
  cbr_mat[, 1] <- rep(seq_len(ng), each = na)
  cbr_mat[, 2] <- rep(seq_len(na), ng)
  cbr_mat[, 3:4] <- summary(sd_report)[cbr_ind, ]
  colnames(cbr_mat) <- c("Class", "Area", "Estimate", "SE")
  cbr_df <- as.data.frame(cbr_mat)

  #---------------- Create dispersion results ---------------------------------#

  dsp_mat <- summary(sd_report)["dispersion", , drop = FALSE]
  rownames(dsp_mat) <- NULL
  colnames(dsp_mat) <- c("Estimate", "SE")
  dsp_df <- as.data.frame(dsp_mat)

  #---------------- Create results list ---------------------------------------#

  results_list <- list(movement_probability_results = mpr_df,
                       natural_mortality_results = nmr_df,
                       capture_bias = cbr_df,
                       dispersion = dsp_df)

  #---------------- Compute AIC -----------------------------------------------#

  num_doubles_or_na <- sum(unlist(lapply(
    tmb_map,
    function(x) length(x) - length(unique(x)) + length(which(is.na(unique(x))))
  )))
  k <- length(unlist(parameter_list)) - num_doubles_or_na
  nll <- tmb_opt$objective
  aic <- 2 * k + 2 * nll

  #---------------- Stop the clock --------------------------------------------#

  tictoc::toc()

  #---------------- Return an mmmTMB object -----------------------------------#

  structure(list(
    adfun      = tmb_obj, # report(),
    model      = tmb_opt, # convergence, objective,
    structure  = tmb_data, # TODO: optionally place in simulated data
    parameter  = tmb_parameters, # Initial values
    optimizer  = optimizer_list,
    results    = results_list,
    map        = tmb_map,
    random     = tmb_random,
    sd_report  = sd_report, # value, sd, cov, par.fixed, cov.fixed, pdHess, gradient.fixed, env
    conv       = conv, # final_grads, bad_eig
    mgc        = mgc,
    aic        = aic),
    class      = "mmmTMB")
}


#' Optimization control options
#'
#' Any arguments to pass to [stats::nlminb()].
#'
#' @param eval.max [numeric(1)] Maximum number of evaluations of the objective
#' function allowed.
#' @param iter.max [numeric(1)] Maximum number of iterations allowed.
#' @param ... Anything else. See the 'Control parameters' section of
#'   [stats::nlminb()].
#'
#' @export
#'
mmmTMBcontrol <- function(eval.max = 1e4, iter.max = 1e4, ...) {
  list(eval.max = eval.max, iter.max = iter.max, ...)
}
